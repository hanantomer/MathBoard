<template>
  <lineWatcher
    :startEntry="{
      editMode: ['SQRT_STARTED'],
      func: setInitialPosition,
    }"
    :drawEntry="{
      editMode: ['SQRT_DRAWING'],
      func: drawLine,
    }"
    :editEntryFirstHandle="{
      editMode: ['SQRT_EDITING'],
      func: modify,
    }"
    :editEntrySecondHandle="{
      editMode: ['SQRT_EDITING'],
      func: modify,
    }"
    :endEntry="{
      editMode: ['SQRT_DRAWING', 'SQRT_EDITING'],
      func: endDrawing,
    }"
    :selectEntry="{
      editMode: ['SQRT_SELECTED'],
      func: selectSqrt,
      event: 'EV_SQRT_SELECTED',
    }"
    :moveByKeyEntry="{
      editMode: ['SQRT_SELECTED'],
      func: moveSqrt,
    }"
    :endSelectionEntry="{
      editMode: ['SQRT_EDITING'],
    }"
  />
  <div v-if="show">
    <line-handle
      drawing-mode="SQRT_DRAWING"
      editing-mode="SQRT_EDITING"
      v-bind:style="{
        left: handleX + 'px',
        top: handleY + 'px',
      }"
    >
    </line-handle>

    <svg
      height="800"
      width="1500"
      xmlns="http://www.w3.org/2000/svg"
      class="line-svg"
    >
      <line
        :x1="sqrtLeft"
        :y1="sqrtY"
        :x2="sqrtRight"
        :y2="sqrtY"
        class="line"
      />
    </svg>
    <p
      class="sqrtsymbol"
      v-bind:style="{
        left: sqrtSymbolLeft + 'px',
        top: sqrtSymbolY + 'px',
      }"
    >
      &#x221A;
    </p>
  </div>
</template>
<script setup lang="ts">
import { computed, ref } from "vue";
import useNotationMutateHelper from "../helpers/notationMutateHelper";
import { useNotationStore } from "../store/pinia/notationStore";
import { useCellStore } from "../store/pinia/cellStore";
import { useEditModeStore } from "../store/pinia/editModeStore";
import {
  HorizontalLineAttributes,
  DotCoordinates,
  SqrtNotationAttributes,
  NotationAttributes,
  MultiCellAttributes,
} from "../../../math-common/src/baseTypes";
import lineHandle from "./LineHandle.vue";
import lineWatcher from "./LineWatcher.vue";

const notationStore = useNotationStore();
const editModeStore = useEditModeStore();
const cellStore = useCellStore();
const notationMutateHelper = useNotationMutateHelper();

let linePosition = ref(<HorizontalLineAttributes>{
  p1x: 0,
  p2x: 0,
  py: 0,
});

const show = computed(() => {
  return (
    editModeStore.isSqrtDrawingMode() ||
    editModeStore.isSqrtEditMode() ||
    editModeStore.isSqrtSelectedMode()
  );
});

let sqrtRight = computed(() => {
  return linePosition.value.p2x;
});

let sqrtLeft = computed(() => {
  return linePosition.value.p1x + cellStore.getCellHorizontalWidth();
});

let sqrtY = computed(() => {
  return linePosition.value.py;
});

let sqrtSymbolLeft = computed(() => {
  return (
    linePosition.value.p1x + (cellStore.getSvgBoundingRect().left ?? 0) - 6
  );
});

let sqrtSymbolY = computed(() => {
  return linePosition.value.py + (cellStore.getSvgBoundingRect().top ?? 0) - 5;
});

let handleX = computed(() => {
  return sqrtRight.value + (cellStore.getSvgBoundingRect().left ?? 0);
});

let handleY = computed(() => {
  return sqrtY.value + (cellStore.getSvgBoundingRect().top ?? 0) - 5;
});

function setInitialPosition(p: DotCoordinates) {
  linePosition.value.p1x = p.x;
  linePosition.value.p2x = p.x;
  linePosition.value.py = p.y;
}

function drawLine(p: DotCoordinates) {
  linePosition.value.p2x = p.x;
}

function endDrawing() {
  const fromCol = Math.round(
    linePosition.value.p1x / cellStore.getCellHorizontalWidth(),
  );

  let toCol = Math.round(
    linePosition.value.p2x / cellStore.getCellHorizontalWidth(),
  );

  let row = Math.round(
    linePosition.value.py / cellStore.getCellVerticalHeight(),
  );

  saveSqrt({ fromCol: fromCol, toCol: toCol, row: row });

  editModeStore.setDefaultEditMode();

  notationStore.resetSelectedNotations();

  resetDrawing();
}

function modify(p: DotCoordinates) {
  linePosition.value.p2x = p.x;
}

function saveSqrt(sqrtAttributes: MultiCellAttributes) {
  if (notationStore.getSelectedNotations().length > 0) {
    let updatedSqrt = {
      ...notationStore.getSelectedNotations().at(0)!,
      ...sqrtAttributes,
    };

    notationMutateHelper.updateSqrtNotation(updatedSqrt);
  } else notationMutateHelper.addSqrtNotation(sqrtAttributes, "SQRT");
}

function resetDrawing() {
  linePosition.value.p1x = linePosition.value.p2x = linePosition.value.py = 0;
}

function selectSqrt(notation: NotationAttributes) {
  const n = notation as SqrtNotationAttributes;

  linePosition.value.p1x = n.fromCol * cellStore.getCellHorizontalWidth();

  linePosition.value.p2x = n.toCol * cellStore.getCellHorizontalWidth();

  linePosition.value.py = n.row * cellStore.getCellVerticalHeight();
}

function moveSqrt(moveX: number, moveY: number) {
  linePosition.value.p1x += moveX;
  linePosition.value.p2x += moveX;
  linePosition.value.py += moveY;
}
</script>
